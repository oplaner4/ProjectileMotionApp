@using ProjectileMotionWeb.Models;
@model _MotionChartModel

<h5 class="mb-2">Chart</h5>

<div class="ml-md-2">
    <canvas id="motionChart" class="mb-3" style="height:@(Math.Round(1000 * (Model.ShowMotionWithoutRezistanceTrajectoryToo ? Model.DegradedMotion : Model.Motion).GetMaxHeight().Val / (Model.ShowMotionWithoutRezistanceTrajectoryToo ? Model.DegradedMotion : Model.Motion).GetLength().Val))px; width:1000px;"></canvas>
</div>

<script>
        $(function () {
            var canvas = $('canvas#motionChart');

            Chart.defaults.global.elements.point.radius = 4;
            Chart.defaults.global.elements.point.hoverRadius = 5;
            Chart.defaults.global.elements.line.borderWidth = 3;
            Chart.defaults.scatter.showLines = true;
            Chart.defaults.global.elements.line.fill = false;
            var easings = ["linear", "easeInQuad", "easeOutQuad", "easeInOutQuad", "easeInCubic", "easeOutCubic", "easeOutQuart", "easeInQuint", "easeOutQuint", "easeOutExpo"];
            Chart.defaults.global.animation.easing = easings[Math.ceil(Math.random() * easings.length) - 1];

            var defaultStepSize = @((Model.ShowMotionWithoutRezistanceTrajectoryToo ? Model.DegradedMotion : Model.Motion).GetLength().Val / 11);

            function getPointsBackgroundsWithBgColorForMaximalPoint(data, defPointBgColor) {
                var pointBackgroundColor = new Array();
                data.forEach(function (v) {
                    pointBackgroundColor.push(v.isFarthest || v.isHighest ? shadeHexColor(defPointBgColor, -25) : defPointBgColor);
                });
                return pointBackgroundColor;
            };

            var dataForMotion = @Html.Raw(Model.GetSpeciallySerializedTrajectory(Model.Motion.GetListPointsOfTrajectory()));
            var dataForSecondMotion =  @Html.Raw(Model.GetSpeciallySerializedTrajectory(Model.DegradedMotion.GetListPointsOfTrajectory()));
            var ticksRenderCallback = function (value) {
                if (value !== this.max)
                    return value.getRoundedVal(2);
            };
            Number.prototype.getRoundedVal = function (digits) {
                return Math.round(this * Math.pow(10, digits)) / Math.pow(10, digits);
            };

            window.motionChartScatter = new Chart(canvas[0].getContext('2d'), {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: '@(Model.ShowMotionWithoutRezistanceTrajectoryToo ? "With rezistance" : "")',
                            pointBackgroundColor: getPointsBackgroundsWithBgColorForMaximalPoint(dataForMotion, "@(Model.Motion.Settings.HexColorOfTrajectory)"),
                            backgroundColor: "@(Model.Motion.Settings.HexColorOfTrajectory)",
                            borderColor: "@(Model.Motion.Settings.HexColorOfTrajectory)",
                        }@if (Model.ShowMotionWithoutRezistanceTrajectoryToo)
                        {
                        <text>
                        , {
                            label: 'Without rezistance',
                            pointBackgroundColor: getPointsBackgroundsWithBgColorForMaximalPoint(dataForSecondMotion, "#6c757d"),
                            backgroundColor: "#6c757d",
                            borderColor: "#848c94",
                        }
                        </text>
                        }

                    ]
                },
                options: {
                    legend: {
                        display: false
                    },
                    tooltips: {
                        callbacks: {
                            label: function (tooltipItem, data) {
                                if (window.pointsDrawingAnimationProgress === true)
                                    return '';

                                var pointData = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
                                var specialPointTitle = '';
                                if (pointData.isFarthest || pointData.isHighest) {
                                    if (pointData.isFarthest && pointData.isHighest) specialPointTitle = "the farthest and highest point";
                                    else if (pointData.isFarthest) specialPointTitle = "the farthest point";
                                    else specialPointTitle = "the highest point";
                                }

                                var label = data.datasets[tooltipItem.datasetIndex].label || '';
                                return (label ? (label + (specialPointTitle ? " - " : ": ")) : "") + (specialPointTitle ? specialPointTitle + ": " : "") + 'x = ' + tooltipItem.xLabel + '; y = ' + tooltipItem.yLabel + '; t = ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index].t;
                            }
                        }
                    },
                    hover: {
                        animationDuration: 70
                    },
                    responsive: true,
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: '@Model.Motion.Saving.GetChartCategoryTitle()'
                            },
                            ticks: {
                                min: 0,
                                max: @((Model.ShowMotionWithoutRezistanceTrajectoryToo ? Model.DegradedMotion : Model.Motion).GetLength().Val),
                                beginAtZero: true,
                                callback: ticksRenderCallback
                            },
                            display: true
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: '@Model.DegradedMotion.Saving.GetChartValueTitle()'
                            },
                            ticks: {
                                min: 0,
                                max: @((Model.ShowMotionWithoutRezistanceTrajectoryToo ? Model.DegradedMotion : Model.Motion).GetMaxHeight().Val),
                                beginAtZero: true,
                                callback: ticksRenderCallback
                            },
                            display: true
                        }]
                    }
                }
            });

            window.pointsDrawingAnimationProgress = false;

            var playPointsDrawingAnimations = function () {
                setTimeout(playPointsDrawingAnimation, window.motionChartScatter.options.hover.animationDuration, 0, dataForMotion);
                if (window.motionChartScatter.data.datasets.length > 1) {
                    setTimeout(playPointsDrawingAnimation, window.motionChartScatter.options.hover.animationDuration, 1, dataForSecondMotion);
                }
            }
            var playPointsDrawingAnimation = function (dataSetIndex, dataSource) {
                window.motionChartScatter.data.datasets[dataSetIndex].data = new Array();

                var dataSourcePointToDrawIndex = 1;
                var pointsMotionDrawingAnimationInterval = null;
                var pointsMotionDrawingAnimationIntervalCallback = function () {

                    window.pointsDrawingAnimationProgress = true;
                    window.motionChartScatter.data.datasets[dataSetIndex].data = dataSource.slice(0, dataSourcePointToDrawIndex + 1);

                    clearInterval(pointsMotionDrawingAnimationInterval);
                    window.motionChartScatter.update();

                    if (dataSourcePointToDrawIndex === dataSource.length - 1) {
                        window.pointsDrawingAnimationProgress = false;
                    }
                    else {
                        pointsMotionDrawingAnimationInterval = setInterval(pointsMotionDrawingAnimationIntervalCallback, dataSource[dataSourcePointToDrawIndex + 1].tMiliseconds - dataSource[dataSourcePointToDrawIndex].tMiliseconds);
                        dataSourcePointToDrawIndex++;
                    }
                };

                pointsMotionDrawingAnimationIntervalCallback();
            };


            playPointsDrawingAnimations();

            $('.btn.btn-replay').on('click', function (e) {
                e.preventDefault();
                if (!window.pointsDrawingAnimationProgress)
                    playPointsDrawingAnimations();
                return false;
            });

            $('form.form-motionChartExport').on('submit', function () {
                $('input[name="canvasbase64ImageUrl"]', this).val(window.motionChartScatter.toBase64Image());
                window.initAndDisplayAlertSuccessMessage('Exporting!', 'Downloading should start soon.');
            });
    });
</script>
