@using ProjectileMotionWeb.Models;
@using ProjectileMotionSource.WithRezistance.Func;
@model _MotionChartModel

<h5 class="mb-2">Chart</h5>

<div class="ml-md-2">
    <canvas id="motionChart" class="mb-3" style="height:@(Math.Round(1000 * (Model.ShowMotionWithoutRezistanceCourseToo ? Model.DegradedMotion : Model.Motion).GetMaxHeight().Val / (Model.ShowMotionWithoutRezistanceCourseToo ? Model.DegradedMotion : Model.Motion).GetLength().Val))px; width:1000px;"></canvas>
</div>

<script>
        $(function () {
            var canvas = $('canvas#motionChart');

            Chart.defaults.global.elements.point.radius = 4;
            Chart.defaults.global.elements.point.hoverRadius = 5;
            Chart.defaults.global.elements.line.borderWidth = 3;
            Chart.defaults.scatter.showLines = true;
            Chart.defaults.global.elements.line.fill = false;
            var easings = ["linear", "easeInQuad", "easeOutQuad", "easeInOutQuad", "easeInCubic", "easeOutCubic", "easeOutQuart", "easeInQuint", "easeOutQuint", "easeOutExpo"];
            Chart.defaults.global.animation.easing = easings[Math.ceil(Math.random() * easings.length) - 1];

            var defaultStepSize = @((Model.ShowMotionWithoutRezistanceCourseToo ? Model.DegradedMotion : Model.Motion).GetLength().Val / 11);

            function getPointsBackgroundsWithBgColorForMaximalPoint(data, defPointBgColor, specialPointBgColor) {
                var pointBackgroundColor = new Array();
                data.forEach(function (v) {
                    pointBackgroundColor.push(v.isFarthest || v.isHighest ? specialPointBgColor : defPointBgColor);
                });
                return pointBackgroundColor;
            };

            var dataForMotion = @Html.Raw(Model.GetSpeciallySerializedFunctionCourse(Model.Motion.GetListFunctionCourse()));
            var dataForSecondMotion =  @Html.Raw(Model.GetSpeciallySerializedFunctionCourse(Model.DegradedMotion.GetListFunctionCourse()));
            var specialPointsBgColors = new Array("#3700ff", "#4b504c");
            var ticksRenderCallback = function (value) {
                if (value !== this.max)
                    return value.getRoundedVal(2);
            };
            Number.prototype.getRoundedVal = function (digits) {
                return Math.round(this * Math.pow(10, digits)) / Math.pow(10, digits);
            };

            window.motionChartScatter = new Chart(canvas[0].getContext('2d'), {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: '@(Model.ShowMotionWithoutRezistanceCourseToo ? "With rezistance" : string.Empty)',
                            pointBackgroundColor: getPointsBackgroundsWithBgColorForMaximalPoint(dataForMotion, "@(Model.Motion is ProjectileMotionWithRezistance ? "#007bff" : "#6c757d")", specialPointsBgColors[@(Model.Motion is ProjectileMotionWithRezistance ? 0 : 1)]),
                            backgroundColor: "@(Model.Motion is ProjectileMotionWithRezistance ? "#007bff" : "#6c757d")",
                            borderColor: "@(Model.Motion is ProjectileMotionWithRezistance ? "#00a0ff" : "#848c94")",
                        }@if (Model.ShowMotionWithoutRezistanceCourseToo)
                        {
                        <text>
                        , {
                            label: 'Without rezistance',
                            pointBackgroundColor: getPointsBackgroundsWithBgColorForMaximalPoint(dataForSecondMotion, "#6c757d", specialPointsBgColors[1]),
                            backgroundColor: "#6c757d",
                            borderColor: "#848c94",
                        }
                        </text>
                        }

                    ]
                },
                options: {
                    legend: {
                        display: false
                    },
                    tooltips: {
                        callbacks: {
                            label: function (tooltipItem, data) {
                                var pointData = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
                                var specialPointTitle = '';
                                if (pointData.isFarthest) {
                                    specialPointTitle = "farthest point";
                                }
                                else if (pointData.isHighest) {
                                    specialPointTitle = "highest point";
                                }
                                
                                var label = data.datasets[tooltipItem.datasetIndex].label || '';
                                return (label ? (label + (specialPointTitle ? " - " : ": ")) : "") + (specialPointTitle ? specialPointTitle + ": " : "") + 'x = ' + tooltipItem.xLabel + '; y = ' + tooltipItem.yLabel;
                            }
                        }
                    },
                    hover: {
                        animationDuration: 70
                    },
                    responsive: true,
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: '@Model.Motion.Saving.GetChartCategoryTitle()'
                            },
                            ticks: {
                                min: 0,
                                max: @((Model.ShowMotionWithoutRezistanceCourseToo ? Model.DegradedMotion : Model.Motion).GetLength().Val),
                                beginAtZero: true,
                                callback: ticksRenderCallback
                            },
                            display: true
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: '@Model.DegradedMotion.Saving.GetChartValueTitle()'
                            },
                            ticks: {
                                min: 0,
                                max: @((Model.ShowMotionWithoutRezistanceCourseToo ? Model.DegradedMotion : Model.Motion).GetMaxHeight().Val),
                                beginAtZero: true,
                                callback: ticksRenderCallback
                            },
                            display: true
                        }]
                    }
                }
            });

            window.pointsDrawingAnimationProgress = false;

            var playPointsDrawingAnimations = function () {
                setTimeout(playPointsDrawingAnimation, window.motionChartScatter.options.hover.animationDuration, 0, dataForMotion);
                if (window.motionChartScatter.data.datasets.length > 1) {
                    setTimeout(playPointsDrawingAnimation, window.motionChartScatter.options.hover.animationDuration, 1, dataForSecondMotion);
                }
            }
            var playPointsDrawingAnimation = function (dataSetIndex, dataSource) {
                window.motionChartScatter.data.datasets[dataSetIndex].data = new Array();

                var dataSourcePointToDrawIndex = 1;
                var pointsMotionDrawingAnimationInterval = null;
                var pointsMotionDrawingAnimationIntervalCallback = function () {

                    window.pointsDrawingAnimationProgress = true;
                    window.motionChartScatter.data.datasets[dataSetIndex].data = dataSource.slice(0, dataSourcePointToDrawIndex + 1);

                    clearInterval(pointsMotionDrawingAnimationInterval);
                    window.motionChartScatter.update();

                    if (dataSourcePointToDrawIndex === dataSource.length - 1) {
                        window.pointsDrawingAnimationProgress = false;
                    }
                    else {
                        pointsMotionDrawingAnimationInterval = setInterval(pointsMotionDrawingAnimationIntervalCallback, dataSource[dataSourcePointToDrawIndex + 1].tMiliseconds - dataSource[dataSourcePointToDrawIndex].tMiliseconds);
                        dataSourcePointToDrawIndex++;
                    }
                };

                pointsMotionDrawingAnimationIntervalCallback();
            };


            playPointsDrawingAnimations();

            $('.btn.btn-replay').on('click', function (e) {
                e.preventDefault();
                if (!window.pointsDrawingAnimationProgress)
                    playPointsDrawingAnimations();
                return false;
            });

            $('form.form-motionChartExport').on('submit', function () {
                $('input[name="canvasbase64ImageUrl"]', this).val(window.motionChartScatter.toBase64Image());
                window.initAndDisplayAlertSuccessMessage('Exporting!', 'Downloading should start soon.');
            });
    });
</script>
